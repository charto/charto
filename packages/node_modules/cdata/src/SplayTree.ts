// This file is part of cdata, copyright (c) 2012, 2013, 2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { SplayItem } from './SplayItem';

export class SplayTree<Key> {

	constructor(
		public deltaFrom: (a: Key, b: Key) => number,
		public combineDupes: boolean
	) {}

	find(key: Key) {
		let node = this.root;
		let d: number;

		while(node) {
			d = this.deltaFrom(key, node.key);

			if(d == 0) return(node.splay());

			if(d < 0) node = node.left;
			else node = node.right;
		}

		return(null);
	}

	insert(key: Key) {
		let node = this.root;
		let newNode: SplayItem<Key> | undefined;
		let d: number;

		if(!node) {
			newNode = new SplayItem<Key>(key);
			this.root = newNode;
			this.first = newNode;
			this.last = newNode;
			return(newNode);
		}

		while(1) {
			d = this.deltaFrom(key, node.key);

			if(d == 0 && this.combineDupes) return(node);

			if(d < 0) {
				if(!node.left) {
					newNode = new SplayItem<Key>(key).link(node.prev, node);
					if(!newNode.prev) this.first = newNode;
					node.left = newNode;
					break;
				}

				node = node.left;
			} else {
				if(!node.right) {
					newNode = new SplayItem<Key>(key).link(node, node.next);
					if(!newNode.next) this.last = newNode;
					node.right = newNode;
					break;
				}

				node = node.right;
			}
		}

		newNode!.parent = node;
		this.root = newNode!.splay();

		return(newNode!);
	}

	remove(node: SplayItem<Key>) {
		var replacement;
		var tmp;

		const parent = node.parent;
		const successor = node.next;
		
		if(node.left && node.right) {
			// Replace node with successor and successor with replacement.
			// Successor can't have a left child.
			replacement = successor!.right;

			// Connect successor's parent (which can be node) with replacement.
			if(successor!.parent!.left == successor) successor!.parent!.left = replacement;
			else successor!.parent!.right = replacement;

			if(replacement) replacement.parent = successor!.parent;

			// Move node's left subtree under successor.
			successor!.left = node.left;
			successor!.left!.parent = successor;

			// Move node's right subtree under successor.
			successor!.right = node.right;
			// Right child can be null if successor is node's right child and replacement is null.
			if(successor!.right) successor!.right!.parent = successor;

			replacement = successor;
		} else {
			replacement = node.left;
			if(!replacement) replacement = node.right;
		}

		// Connect node's parent with replacement.
		if(!parent) this.root = replacement;
		else if(parent.left == node) parent.left = replacement;
		else parent.right = replacement;
		if(replacement) replacement.parent = parent;

		if(successor) successor.prev = node.prev;
		else this.last = node.prev;

		if(node.prev) node.prev.next = successor;
		else this.first = successor;

		if(parent) this.root = parent.splay();
	}

	/** Swap nodes a and b in the tree.
	  * Note: prev and next pointers are not updated! */
	swap(a: SplayItem<Key>, b: SplayItem<Key>) {
		if(a == b) return;

		const left = b.left;
		const right = b.right;

		b.left = a.left;
		a.left = left;

		b.right = a.right;
		a.right = right;

		if(a.parent == b.parent) {
			if(a.parent!.left == a) {
				a.parent!.left = b;
				a.parent!.right = a;
			} else {
				a.parent!.left = a;
				a.parent!.right = b;
			}
		} else {
			const t = b.parent;
			b.parent = a.parent;
			a.parent = t;

			if(a.parent == a) a.parent = b;
			if(b.parent == b) b.parent = a;

			if(!a.parent) this.root = a;
			else if(a.parent.left == b) a.parent.left = a;
			else a.parent.right = a;

			if(!b.parent) this.root = b;
			else if(b.parent.left == a) b.parent.left = b;
			else b.parent.right = b;
		}

		if(a.left) a.left.parent = a;
		if(b.left) b.left.parent = b;

		if(a.right) a.right.parent = a;
		if(b.right) b.right.parent = b;
	}

	reverse(first = this.first, last = this.last) {
		if(first == last) return;

		first = first!;
		last = last!;

		let firstPrev = first.prev;
		let lastNext = last.next;

		let next = first.next;
		let prev = last.prev;

		if(firstPrev) {
			firstPrev.next = last;
			last.prev = firstPrev;
		} else {
			this.first = last;
			last.prev = null;
		}

		if(lastNext) {
			lastNext.prev = first;
			first.next = lastNext;
		} else {
			this.last = first;
			first.next = null;
		}

		while(first != last && first != firstPrev) {
			this.swap(first, last);

			firstPrev = last;
			lastNext = first;

			first = next!;
			last = prev!;

			next = first.next;
			prev = last.prev;

			firstPrev.next = last;
			last.prev = firstPrev;

			lastNext.prev = first;
			first.next = lastNext;
		}
	}

	root?: SplayItem<Key> | null;
	first?: SplayItem<Key> | null;
	last?: SplayItem<Key> | null;

}
