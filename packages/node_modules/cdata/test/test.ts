import { BinaryHeap, SplayItem, SplayTree } from '..';

function compare(a: number, b: number) { return(a - b); }

const unsorted: number[] = [];

for(let num = 0; num < 50; ++num) {
	unsorted[num] = ~~(Math.random() * 25);
}

const correct = unsorted.slice(0).sort(compare);

function testHeap() {
	const heap = new BinaryHeap(compare);
	const result = [];

	for(let item of unsorted) heap.insert(item);

	while(!heap.isEmpty()) {
		result.push(heap.extractTop());
	}

	if((result.join(' ') == correct.join(' '))) {
		console.log('BinaryHeap OK');
	} else {
		console.error('Error in BinaryHeap');
		process.exit(1);
	}
}

// Traverse tree in-order and verify all neighbors.

function verifyTree(tree: SplayTree<number>) {
	let prev: SplayItem<number> | null = null;

	function rec(node: SplayItem<number>, parent?: SplayItem<number> | null) {
		if(node.left) rec(node.left, node);

		if(
			node.parent != parent ||
			node.prev != prev ||
			(prev && (prev.next != node || prev.key > node.key)) ||
			(!prev && tree.first != node)
		) {
			console.error('Error in SplayTree');
			process.exit(1);
		}

		prev = node;

		if(node.right) rec(node.right, node);
	}

	if(tree.root) rec(tree.root, null);

	if(tree.last != prev) {
		console.error('Error in SplayTree');
		process.exit(1);
	}
}

function testTree() {
	const tree = new SplayTree(compare, false);
	const result = [];
	const nodeList = unsorted.map((key) => tree.insert(key));
	const keyList: number[] = [];

	let threshold: number;
	let node: SplayItem<number>;
	let key: number;

	// Test random inserts, removes and rotations.

	for(let i = 0; i < 300; ++i) {
		threshold = i < 150 ? 0.7 : 0.3;

		if(Math.random() < threshold && nodeList.length) {
			node = nodeList.splice(~~(Math.random() * nodeList.length), 1)[0]!;
			keyList.push(node.key);
			tree.remove(node);
		} else if(keyList.length) {
			key = keyList.splice(~~(Math.random() * keyList.length), 1)[0];
			nodeList.push(tree.insert(key));
		}

		verifyTree(tree);

		if(i < 200) {
			for(let j = 0; j < 10; ++j) {
				if(nodeList.length) {
					node = nodeList[~~(Math.random() * nodeList.length)];
					if(node.parent) {
						if(Math.random() < 0.5 && node.right) {
							node.rotateLeft();
						} else if(node.left) {
							node.rotateRight();
						}
					}
				}
			}

			verifyTree(tree);
		}
	}

	// Test random swaps.

	for(let i = 0; i < 10000; ++i) {
		const a = nodeList[~~(Math.random() * nodeList.length)];
		const b = nodeList[~~(Math.random() * nodeList.length)];

		tree.swap(a, b);
		tree.swap(a, b);

		verifyTree(tree);
	}

	for(let key of keyList) tree.insert(key);

	verifyTree(tree);

	while(tree.first) {
		result.push(tree.first.key);
		tree.remove(tree.first);
	}

	if((result.join(' ') == correct.join(' '))) {
		console.log('SplayTree OK');
	} else {
		console.error('Error in SplayTree');
		process.exit(1);
	}
}

testHeap();
testTree();
