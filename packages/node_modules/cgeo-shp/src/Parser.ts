// This file is part of cgeo-shp, copyright (c) 2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as stream from 'stream';

import * as cgeo from 'cgeo';
import * as cbin from 'cbin';
import { Geometry } from './Geometry';

const incomplete = new Error();

export interface OptionsSHP {
	flipXY?: boolean;
}

export class State implements OptionsSHP {

	constructor(options: OptionsSHP = {}, geom?: Geometry & cgeo.Geometry) {
		this.flipXY = options.flipXY || false;

		if(geom) {
			if(geom.hasZ()) { this.hasZ = true; this.kindOffset = 10; }
			if(geom.hasM()) { this.hasM = true; if(!this.hasZ) this.kindOffset = 20; }
		}
	}

	flipXY: boolean;
	hasZ: boolean;
	hasM: boolean;
	kindOffset = 0;

	recordEnd: number;
	partCount: number;
	pointCount: number;
	partOffset: number;
	partOffsetList: number[];
	partNum: number;
	step: number;

	reader: cbin.Reader;
	writer: cbin.Writer;

}

const shpTypeList: ({ new(): Geometry & cgeo.Geometry } | null)[] = [];

export function registerType(Type: { new(): Geometry & cgeo.Geometry }, kind: number) {
	shpTypeList[kind] = Type;
}

export class Parser extends stream.Transform {

	constructor(options?: OptionsSHP) {
		super({ objectMode: true });

		const state = new State();
		state.reader = new cbin.Reader();

		state.reader.endian = cbin.CEndian.big;

		this.state = state;
		this.handler = this.parseFileHeader;
	}

	parseFileHeader(buffered: number) {
		if(buffered < 100) return(incomplete);

		const reader = this.state.reader;

		if(reader.u32() != 9994) return(new Error('Unknown shapefile magic'));
		// Skip unused bytes.
		reader.skip(20);
		this.fileLength = reader.u32() * 2;

		// Spec says endianness changes in the middle of the shapefile header.
		reader.endian = cbin.CEndian.little;

		if(reader.u32() != 1000) return(new Error('Unknown shapefile version'));

		this.geometryType = reader.u32();

		// Skip bounding box for now.
		reader.skip(64);

		// Start parsing shape records.
		this.handler = this.parseRecordHeader;
	}

	parseRecordHeader(buffered: number) {
		if(buffered < 12) {
			return(incomplete);
		}

		const reader = this.state.reader;

		reader.endian = cbin.CEndian.big;

		const num = reader.u32();
		const recordLen = reader.u32() * 2;

		this.state.recordEnd = reader.chunkOffset + reader.pos + recordLen;

		reader.endian = cbin.CEndian.little;

		const geometryType = reader.u32();

		if(geometryType != this.geometryType) {
			return(new Error('Geometry type mismatch: ' + geometryType + ' vs ' + this.geometryType));
		}

		const Type = shpTypeList[geometryType];
		if(Type) {
			this.state.step = 0;
			this.target = new Type();
			this.output.push(this.target);
			this.handler = this.parseRecord;
		} else {
			this.handler = this.skipRecord;
		}
	}

	parseRecord(buffered: number) {
		const state = this.state;

		if(!this.target!.parseSHP(state, buffered)) return(incomplete);

		const reader = state.reader;
		const remaining = state.recordEnd - reader.chunkOffset - reader.pos;
		this.handler = remaining ? this.skipRecord : this.parseRecordHeader;
	}

	skipRecord(buffered: number) {
		const reader = this.state.reader;
		const remaining = this.state.recordEnd - reader.chunkOffset - reader.pos;

		if(buffered >= remaining) {
			buffered = remaining;
			this.handler = this.parseRecordHeader;
		}

		if(buffered) reader.skip(buffered);
		if(buffered < remaining) return(incomplete);
	}

	_transform(chunk: Buffer, enc: string, flush: (err: any, chunk?: cgeo.Geometry[]) => void) {
		const reader = this.state.reader;
		let err: Error | void;

		reader.push(chunk);
		this.output = [];

		do {
			err = this.handler(reader.len - reader.pos + reader.futureLen);
		} while(!err);

		if(err != incomplete) {
			flush(err, this.output);
			this.end();
			return;
		}

		flush(null, this.output);
	}

	_flush(flush: (err: any, chunk?: cgeo.Geometry[]) => void) {
		const reader = this.state.reader;

		if(reader.chunkOffset + reader.len < this.fileLength) {
			flush(new Error('Premature end of file'));
		}
	}

	state: State;
	output: (Geometry & cgeo.Geometry)[];
	target?: Geometry & cgeo.Geometry;
	handler: (buffered: number) => Error | void;
	fileLength: number;
	geometryType: number;

}
