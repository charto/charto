// This file is part of cgeo-shp, copyright (c) 2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as stream from 'stream';

import * as cgeo from 'cgeo';
import * as cbin from 'cbin';
import { Geometry } from './Geometry';

export const incomplete = new Error();

export class Parser extends stream.Transform {

	constructor() {
		super({ objectMode: true });

		this.reader = new cbin.Reader();

		this.reader.endian = cbin.CEndian.big;
		this.handler = this.parseFileHeader;
	}

	parseFileHeader(buffered: number) {
		if(buffered < 100) return(incomplete);

		const reader = this.reader;

		if(reader.u32() != 9994) return(new Error('Unknown shapefile magic'));
		// Skip unused bytes.
		reader.skip(20);
		this.fileLength = reader.u32() * 2;

		// Spec says endianness changes in the middle of the shapefile header.
		reader.endian = cbin.CEndian.little;

		if(reader.u32() != 1000) return(new Error('Unknown shapefile version'));

		this.geometryType = reader.u32();

		// Skip bounding box for now.
		reader.skip(64);

		// Start parsing shape records.
		this.handler = this.parseRecordHeader;
	}

	parseRecordHeader(buffered: number) {
		const reader = this.reader;

		if(buffered < 12) {
			return(incomplete);
		}

		reader.endian = cbin.CEndian.big;

		const num = reader.u32();
		this.recordLen = reader.u32() * 2 - 4;

		reader.endian = cbin.CEndian.little;

		const geometryType = reader.u32();

		if(geometryType != this.geometryType) {
			return(new Error('Geometry type mismatch: ' + geometryType + ' vs ' + this.geometryType));
		}

		console.log(num + ' ' + this.recordLen + ' ' + geometryType);

		this.handler = this.parseRecord;
	}

	parseRecord(buffered: number) {
		let recordLen = this.recordLen;

		if(!buffered) return(incomplete);
		if(buffered > recordLen) buffered = recordLen;

		this.reader.skip(buffered);
		recordLen -= buffered;

		if(!recordLen) {
			this.handler = this.parseRecordHeader;
		}

		this.recordLen = recordLen;
	}

	_transform(chunk: Buffer, enc: string, flush: (err: any, chunk?: cgeo.Geometry[]) => void) {
		const reader = this.reader;
		const geomList: cgeo.Geometry[] = [];
		let err: Error | void;

		reader.push(chunk);

		do {
			err = this.handler(reader.len - reader.pos + reader.futureLen);
		} while(!err);

		if(err != incomplete) {
			flush(err);
			this.end();
			return;
		}

		flush(null, geomList);
	}

	_flush(flush: (err: any, chunk?: cgeo.Geometry[]) => void) {
		if(this.reader.chunkOffset + this.reader.len < this.fileLength) {
			flush(new Error('Premature end of file'));
		}
	}

	reader: cbin.Reader;
	handler: (buffered: number) => Error | void;
	fileLength: number;
	geometryType: number;
	recordLen: number;
}
