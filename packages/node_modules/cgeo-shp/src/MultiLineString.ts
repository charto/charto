// This file is part of cgeo-shp, copyright (c) 2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as cgeo from 'cgeo';
import { State } from './Parser';

@cgeo.mixin()
export class MultiLineString extends cgeo.MultiLineString {

	parseSHP(state: State, buffered: number) {
		const reader = state.reader;
		let num: number;
		let count: number;
		let offset: number;

		switch(state.step) {
			// Polyline header.
			case 0:
				if(buffered < 40) return(false);

				// Skip bounding box for now.
				reader.skip(32);

				state.partCount = reader.u32();
				state.pointCount = reader.u32();
				state.partOffset = 0;
				state.partOffsetList = [];

				// Skip parsing empty geometries.
				if(!state.partCount || !state.pointCount) return(true);

				buffered -= 40;
				++state.step;

			// Fallthru: Offsets to point list.
			case 1:
				num = state.partOffsetList.length;
				count = state.partCount - num;

				if(count > (buffered >> 2)) count = buffered >> 2;
				buffered -= count << 2;

				while(count--) {
					offset = reader.u32();

					if(offset >= state.pointCount) {
						throw(new Error('Invalid LineString part offset: ' + offset + ' > ' + state.pointCount));
					}

					state.partOffsetList[num++] = offset;
				}

				if(num < state.partCount) return(false);

				state.partNum = 0;
				++state.step;

			// Fallthru: Skip initial unused points.
			// A waste of space, but the spec allows them...
			case 2:

				num = state.partOffset;
				offset = state.partOffsetList[state.partNum];

				count = offset - num;
				if(count > (buffered >> 4)) count = buffered >> 4;

				if(count) {
					reader.skip(count << 4);
					buffered -= count << 4;

					num += count;
					state.partOffset = num;
				}

				if(num < offset) return(false);

				this.addChild(new cgeo.LineString());

				++state.partNum;
				++state.step;

			// Fallthru: Point list.
			case 3:
				num = state.partOffset;

				if(state.partNum < state.partCount) {
					offset = state.partOffsetList[state.partNum];
				} else {
					offset = state.pointCount;
				}

				count = offset - num;
				if(count > (buffered >> 4)) count = buffered >> 4;

				const child = this.childList[state.partNum - 1];
				const x = child.x;
				const y = child.y;

				num += count;
				state.partOffset = num;

				while(count--) {
					if(state.flipXY) {
						y.push(reader.f64());
						x.push(reader.f64());
					} else {
						x.push(reader.f64());
						y.push(reader.f64());
					}
				}

				if(num < offset) return(false);

				if(++state.partNum >= state.partCount) return(true);

				this.addChild(new cgeo.LineString());
				return(false);
		}
	}

}
