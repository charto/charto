import * as cxml from 'cxml';
import * as cgeo from 'cgeo';
import 'cgeo-wkt';
import { ConfigGML, Parser, GeometryToken } from '..';
import '..';

const pts2: cgeo.CurveSpec = [ { x: 12, y: 34 }, { x: 56, y: 78 } ];

const point = new cgeo.Point( { x: 12, y: 34, z: 0, m: 0 } );
const line = new cgeo.LineString(pts2);
const circle = new cgeo.CircularString({ x: [ 56, 90, 12 ], y: [ 78, 90, 34 ] });
const ring1 = [ { x: 12, y: 34 }, { x: 56, y: 78 }, { x: 90, y: 90 }, { x: 12, y: 34 } ];
const ring2 = { x: [ 87, 43, 0, 87 ], y: [65, 21, 0, 65] };
const polygon = new cgeo.Polygon([ ring1, ring2 ]);
const compound = new cgeo.CompoundCurve([ line, circle ]);
const curvePolygon = new cgeo.CurvePolygon([ compound, ring1 ]);

const set = new cgeo.GeometryCollection([ point, line, polygon ] as cgeo.Geometry[]);

set.addChild(new cgeo.MultiPoint(pts2));
set.addChild(new cgeo.MultiLineString([ pts2, { x: [ 87, 43 ], y: [ 65, 21 ] } ]));
set.addChild(new cgeo.MultiPolygon([ polygon ]));
set.addChild(new cgeo.PolyhedralSurface([ polygon ]));
set.addChild(new cgeo.MultiCurve([ line, compound ]));
set.addChild(new cgeo.MultiSurface([ polygon, curvePolygon ]));

const wkt = set.toWKT();

const xmlConfig = new cxml.ParserConfig({ parseUnknown: true });
const gmlConfig = new ConfigGML({ xmlConfig });

const writer1 = new cxml.Writer(xmlConfig);
const writer2 = new cxml.Writer(xmlConfig, { gmlConfig });
const xmlParser = xmlConfig.createParser();
const gmlParser = new Parser(gmlConfig);
let data1: string;

xmlConfig.bindNamespace(new cxml.Namespace('gml', 'http://www.opengis.net/gml'));

const namespaceList: cxml.Namespace[] = [];

for(let ns of xmlConfig.namespaceList) {
	if(ns) namespaceList[ns.base.id] = ns.base;
}

const chunk = cxml.TokenChunk.allocate(set.toGML(gmlConfig));
chunk.namespaceList = namespaceList;

writer2.pipe(process.stdout);
xmlParser.pipe(gmlParser);

writer1.on('data', (chunk: string) => {
	if(chunk) data1 += chunk;
	xmlParser.write(chunk);
});

writer1.on('end', (chunk: string) => {
	if(chunk) data1 += chunk;
	xmlParser.end(chunk);
});

let geometryToken: GeometryToken;

gmlParser.on('data', (chunk: cxml.TokenChunk) => {
	if(chunk && chunk.length) geometryToken = chunk.buffer[chunk.length - 1] as GeometryToken;
	writer2.write(chunk)
});

gmlParser.on('end', (chunk: cxml.TokenChunk) => {
	if(chunk && chunk.length) geometryToken = chunk.buffer[chunk.length - 1] as GeometryToken;

	if(geometryToken.geometry.toWKT() != wkt) {
		console.error('WKT output mismatch');
	}

	writer2.end(chunk)
});

writer1.write(chunk);
writer1.end();
