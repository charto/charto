import * as stream from 'stream';

import * as cxml from 'cxml';
import * as cgeo from 'cgeo';
import { Geometry } from './Geometry';
import { GeometryToken } from './GeometryToken';
import { ConfigGML, GeometryType } from './ConfigGML';

export class Parser<WrapperToken extends cxml.Token = GeometryToken> extends stream.Transform {

	constructor(
		public gmlConfig: ConfigGML,
		public Wrapper: { new(geometry: cgeo.Geometry): WrapperToken } = GeometryToken as any
	) {
		super({ objectMode: true });
	}

	/** gml:exterior
	  * Make polygon exterior ring the first one.
	  * GML only supports one exterior ring. */

	exterior(token: cxml.ElementToken) {
		const childList = this.childList;

		if(token.kind == cxml.TokenKind.close && childList) {
			childList[0] = childList.pop() || null;
		}
	}

	/** gml:pos or gml:posList
	  * Parse inner text node as a coordinate list
	  * and handle gml:srsDimension attribute. */

	pos(token: cxml.ElementToken) {
		if(token.kind == cxml.TokenKind.open) {
			this.dimension = 2;
		} if(token.kind == cxml.TokenKind.emitted) {
			if(this.dimension > 2 && this.coordList && !this.coordList.z) {
				this.target.push(this.coordList.z = []);
			}

			if(this.dimension > 3 && this.coordList && !this.coordList.m) {
				this.target.push(this.coordList.m = []);
			}

			this.isPos = true;
		} else if(token.kind == cxml.TokenKind.close) {
			this.isPos = false;
		}
	}

	_transform(chunk: cxml.TokenChunk | null, enc: string, flush: (err: any, chunk: cxml.TokenChunk | null) => void) {
		if(!chunk) {
			flush(null, null);
			return;
		}

		const { gml, geometryTbl, tokenTbl } = this.gmlConfig;
		const buffer = chunk.buffer;
		let token: typeof buffer[0];

		const posLast = chunk.length - 1;
		let posRead = -1;
		let posWrite = -1;

		let depth = this.depth;
		let captureDepth = this.captureDepth;

		let TypeHandler: typeof geometryTbl[0];
		let handler: typeof tokenTbl[0];

		while(posRead < posLast) {
			token = buffer[++posRead];

			if(token instanceof cxml.ElementToken) {
				TypeHandler = geometryTbl[token.id!];

				if(token.kind == cxml.TokenKind.open) ++depth;

				if(TypeHandler) {
					if(token.kind == cxml.TokenKind.open) {
						if(depth < captureDepth) captureDepth = depth;
					} else if(token.kind == cxml.TokenKind.emitted) {
						TypeHandler.initGML(this, token);
					} else if(token.kind == cxml.TokenKind.close) {
						const geometry = TypeHandler.finishGML(this, token);

						if(geometry) {
							if(depth == captureDepth) {
								buffer[++posWrite] = new this.Wrapper(geometry);
							} else if(this.childList) {
								this.childList.push(geometry);
							}
						}
					}
				} else if(depth >= captureDepth) {
					handler = tokenTbl[token.id!];
					if(handler) handler.call(this, token);
				} else buffer[++posWrite] = token;

				if(token.kind == cxml.TokenKind.close) {
					--depth;
					if(depth < captureDepth) captureDepth = Infinity;
				}
			} else if(depth < captureDepth) {
				buffer[++posWrite] = token;
			} else if(token instanceof cxml.AttributeToken) {
				if(token.id == gml.srsDimension.id) this.isDimension = true;
			} else if(typeof(token) == 'string') {
				if(this.isPos && this.coordList) {
					const dimension = this.dimension;
					const target = this.target;
					let axis = 0;

					for(let coord of token.split(' ')) {
						target[axis++].push(+coord);
						if(axis >= dimension) axis = 0;
					}
				} else if(this.isDimension) {
					this.dimension = +token;
					this.isDimension = false;
				}
			}
		}

		chunk.length = posWrite + 1;

		flush(null, chunk);

		this.depth = depth;
		this.captureDepth = captureDepth;
	}

	depth = 0;
	captureDepth = Infinity;

	dimension = 2;

	isPos = false;
	isDimension = false;

	coordList?: cgeo.PointListSpec;
	childList?: ((Geometry & cgeo.Geometry) | null)[];
	childListStack: ((Geometry & cgeo.Geometry) | null)[][] = [];
	target: number[][];
}
