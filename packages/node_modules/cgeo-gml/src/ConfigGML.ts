// This file is part of cgeo-gml, copyright (c) 2017 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as cgeo from 'cgeo';
import * as schema from 'charto-schema';
import { OpenToken, TokenElement, ElementToken, AttributeToken, ParserConfig, defineElement, defineAttribute } from 'cxml';
import { Geometry } from './Geometry';
import { Parser } from './Parser';

export interface OptionsGML {
	xmlConfig: ParserConfig;
	flipXY?: boolean;
}

export const gml = schema.gml.jsx(defineElement, defineAttribute);

export type GeometryType = typeof Geometry & typeof cgeo.Geometry;

export class ConfigGML implements OptionsGML {

	constructor(options: OptionsGML) {
		this.xmlConfig = options.xmlConfig;
		this.flipXY = options.flipXY || false;

		this.xmlConfig.jsxRegister({ gml }, ({ gml }) => {
			const element = this.elementTbl;
			const member = this.memberTbl;
			const geometry = this.geometryTbl;
			const token = this.tokenTbl;
			this.gml = gml;

			element[cgeo.GeometryKind.multiPoint] = gml.MultiPoint;
			element[cgeo.GeometryKind.multiLineString] = gml.MultiLineString;
			element[cgeo.GeometryKind.multiPolygon] = gml.MultiPolygon;
			element[cgeo.GeometryKind.geometryCollection] = gml.MultiGeometry;
			element[cgeo.GeometryKind.compoundCurve] = gml.CompositeCurve;
			element[cgeo.GeometryKind.multiCurve] = gml.MultiCurve;
			element[cgeo.GeometryKind.multiSurface] = gml.MultiSurface;
			element[cgeo.GeometryKind.polyhedralSurface] = gml.PolyhedralSurface;

			member[cgeo.GeometryKind.multiPoint] = gml.pointMembers;
			member[cgeo.GeometryKind.multiLineString] = gml.lineStringMembers;
			member[cgeo.GeometryKind.multiPolygon] = gml.polygonMembers;
			member[cgeo.GeometryKind.geometryCollection] = gml.geometryMembers;
			member[cgeo.GeometryKind.compoundCurve] = gml.curveMembers;
			member[cgeo.GeometryKind.multiCurve] = gml.curveMembers;
			member[cgeo.GeometryKind.multiSurface] = gml.surfaceMembers;
			member[cgeo.GeometryKind.polyhedralSurface] = gml.polygonPatches;

			geometry[gml.Point.id!] = cgeo.Point;
			geometry[gml.LineString.id!] = cgeo.LineString;
			geometry[gml.Polygon.id!] = cgeo.Polygon;
			geometry[gml.MultiPoint.id!] = cgeo.MultiPoint;
			geometry[gml.MultiLineString.id!] = cgeo.MultiLineString;
			geometry[gml.MultiPolygon.id!] = cgeo.MultiPolygon;
			geometry[gml.MultiGeometry.id!] = cgeo.GeometryCollection;
			geometry[gml.Arc.id!] = cgeo.CircularString;
			geometry[gml.CompositeCurve.id!] = cgeo.CompoundCurve;
			geometry[gml.MultiCurve.id!] = cgeo.MultiCurve;
			geometry[gml.MultiSurface.id!] = cgeo.MultiSurface;
			geometry[gml.PolyhedralSurface.id!] = cgeo.PolyhedralSurface;

			geometry[gml.LinearRing.id!] = cgeo.LineString;
			geometry[gml.PolygonPatch.id!] = cgeo.Polygon;

			token[gml.exterior.id!] = Parser.prototype.exterior;
			token[gml.pos.id!] = Parser.prototype.pos;
			token[gml.posList.id!] = Parser.prototype.pos;
		});
	}

	xmlConfig: ParserConfig;
	flipXY: boolean;
	gml: typeof gml;
	elementTbl: OpenToken[] = [];
	memberTbl: OpenToken[] = [];
	geometryTbl: GeometryType[] = [];
	tokenTbl: ((this: Parser<any>, token: ElementToken) => any)[] = [];

}
