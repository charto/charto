// This file is part of charto-3d, copyright (C) 2016-2017 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { Vector3 } from './Vector3';
import { TransMatrix } from './TransMatrix';

export interface PerspectiveCameraSpec {
	yfov: number;
	aspect: number;
	near: number;
	far: number;

	position?: Vector3;
	direction?: Vector3;
	up?: Vector3;
}

/** Camera and projection handling. */

export class PerspectiveCamera implements PerspectiveCameraSpec {

	constructor(spec: PerspectiveCameraSpec) {
		this.yfov = spec.yfov;
		this.near = spec.near;
		this.far = spec.far;

		this.ySlope = Math.tan(this.yfov * Math.PI / 360);
		this.setAspect(spec.aspect);

		this.position = spec.position || new Vector3(0, 0, 0);
		this.setDirection(spec.direction || new Vector3(0, 0, 1));
		this.up = spec.up || new Vector3(0, 1, 0);
	}

	setAspect(aspect: number) {
		this.aspect = aspect;
		this.xfov = Math.atan(this.aspect * this.ySlope) * 360 / Math.PI;

		this.updateProjection();
	}

	setDirection(direction: Vector3) {
		this.direction = direction.setNormalized();
	}

	rotateBy(sin: number, cos: number, axis: Vector3) {
		this.direction = TransMatrix.makeRotate(
			sin, cos, axis
		).transformVector(this.direction).setNormalized();
	}

	getOrientMatrix() {
		return(TransMatrix.makeOrient(this.position, this.direction, this.up));
	}

	/** Create a new projection matrix (different from standard OpenGL).
	  * x goes right.
	  * y goes up.
	  * z goes away. */

	updateProjection() {
		const zmin = this.near;
		const zmax = this.far;
		const ymax = zmin * this.ySlope;
		const ymin = -ymax;
		const xmin = ymin * this.aspect;
		const xmax = ymax * this.aspect;

		const m = this.projection.data;

		m[0]  =         2*zmin / (xmax - xmin);
		m[5]  =         2*zmin / (ymax - ymin);
		// m[8]=-(xmax + xmin) / (xmax - xmin);
		// m[9]=-(ymax + ymin) / (ymax - ymin);
		m[10] =  (zmax + zmin) / (zmax - zmin);
		m[14] = -2*zmax*zmin   / (zmax - zmin);
		m[11] =  1;
	}

	getInverseProjection() {
		const zmin = this.near;
		const zmax = this.far;
		const ymax = zmin * this.ySlope;
		const ymin = -ymax;
		const xmin = ymin * this.aspect;
		const xmax = ymax * this.aspect;

		const matrix = new TransMatrix();
		const m = matrix.data;

		m[0]  =  (xmax - xmin) / (2*zmin);
		m[5]  =  (ymax - ymin) / (2*zmin);
		// m[12]=(xmax + xmin) / (2*zmin);
		// m[13]=(ymax + ymin) / (2*zmin);
		m[11] = -(zmax - zmin) / (2*zmax*zmin);
		m[15] =  (zmax + zmin) / (2*zmax*zmin);
		m[14] =  1;
		// NOTE: Need to divide m[14] and m[15] here
		// by m[11] in this.projection if it's nonzero.

		return(matrix);
	}

	/** Horizontal field of view. */
	xfov: number;
	/** Vertical field of view. */
	yfov: number;
	/** Drawing area aspect ratio. */
	aspect: number;
	/** Ratio between pixel size and z coordinate. */
	ySlope: number;

	/** Distance to near clipping plane where everything is projected. */
	readonly near: number;
	/** Far clipping plane, distance limit for drawn objects. */
	readonly far: number;

	/** Perspective projection matrix. */
	projection = new TransMatrix();

	position: Vector3;
	direction: Vector3;
	up: Vector3;

}
