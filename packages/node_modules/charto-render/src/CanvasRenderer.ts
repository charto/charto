// This file is part of charto-render, copyright (c) 2017 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { Point } from 'cgeo';
import { BBox, Layer, LayerFeatures } from 'charto-model';
import { RendererOptions, RendererState }from './RendererState';

export interface CanvasRendererOptions extends RendererOptions {

	canvas: HTMLCanvasElement;

}

export class CanvasRendererState extends RendererState {

	gc: CanvasRenderingContext2D;

}

export function circle(gc: CanvasRenderingContext2D, x: number, y: number, r: number) {
	gc.moveTo(x, y - r);
	gc.arcTo(x + r, y - r, x + r, y, r);
	gc.arcTo(x + r, y + r, x, y + r, r);
	gc.arcTo(x - r, y + r, x - r, y, r);
	gc.arcTo(x - r, y - r, x, y - r, r);
}

export class CanvasRenderer {

	preparePoint(radius: number, edge: number) {
		if(this.canvas) return;

		// Pre-render 64 points with different intensity levels.

		const canvas = document.createElement('canvas');
		canvas.width = radius * 2 * 64;
		canvas.height = radius * 2;

		const gc = canvas.getContext('2d')!;

		if(edge) {
			gc.fillStyle = 'rgb(255, 255, 255)';

			gc.beginPath();

			for(let x = 0; x < 64; ++x) {
				circle(gc, (x * 2 + 1) * radius, radius, radius);
			}

			gc.fill();
		}

		for(let x = 0; x < 64; ++x) {
			gc.fillStyle = 'rgb(255, ' + Math.round(Math.pow(14 / 15, x + 1) * 255) + ', 0)';

			gc.beginPath();
			circle(gc, (x * 2 + 1) * radius, radius, radius - edge);
			gc.fill();
		}

		this.canvas = canvas;
	}

	renderPoint(geom: Point, state: CanvasRendererState) {
		const x = geom.y * state.scaleX + state.offsetX;
		const y = geom.x * state.scaleY + state.offsetY;
		const size = state.pointRadius * 2;
		let weight = (geom as any).count || 1;

		if(weight > 64) weight = 64;

		state.gc.drawImage(this.canvas, (weight - 1) * size, 0, size, size, x - state.pointRadius, y - state.pointRadius, size, size);
	}

	render(options: CanvasRendererOptions) {
		const state = new CanvasRendererState(options);

		const gc = options.canvas.getContext('2d')!;

		state.gc = gc;
		state.pointRadius = 7 * state.pixelRatio;

		this.preparePoint(state.pointRadius, 2 * state.pixelRatio);

		// gc.lineWidth = 2 * pixelRatio;
		// gc.strokeStyle = 'rgb(192, 160, 128)';
		// gc.fillStyle = 'rgba(224, 192, 160, 0.5)';

		const pointList: Point[] = [];

		for(let LayerFeatures of options.features) {
			for(let feature of LayerFeatures.features) {
				for(let geom of feature.geometries) {
					if(geom instanceof Point) pointList.push(geom);
				}
			}
		}

		gc.globalCompositeOperation = 'multiply';

		// Blue channel is border opacity
		// Green channel is fill transparency

		for(let geom of pointList) {
			this.renderPoint(geom, state);
		}

		const data = gc.getImageData(0, 0, options.pixelWidth, options.pixelHeight);
		const buf = data.data;
		const len = options.pixelWidth * options.pixelHeight * 4;

		for(let pos = 0; pos < len; pos += 4) {
			buf[pos + 3] &= ~buf[pos + 1] | buf[pos + 2];
		}

		gc.putImageData(data, 0, 0);
	}

	canvas: HTMLCanvasElement;

}
