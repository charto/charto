// This file is part of charto-render, copyright (c) 2017 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { Point } from 'cgeo';
import { BBox, Layer, LayerFeatures } from 'charto-model';
import { RendererOptions, RendererState }from './RendererState';
import { Shader, Attribute } from 'charto-3d';

import * as pointVertex from '../glsl/point.vert!';
import * as pointFragment from '../glsl/point.frag!';

export interface GLRendererOptions extends RendererOptions {

	canvas: HTMLCanvasElement;

}

export class GLRendererState extends RendererState {

	constructor(options: RendererOptions, margin: number) {
		super();

		const marginScaleX = options.pixelWidth / (options.pixelWidth + margin * 2);
		const marginScaleY = options.pixelHeight / (options.pixelHeight + margin * 2);

		const { s, w, n, e } = options.bbox;
		this.pixelRatio = options.pixelRatio || 1;
		this.scaleX = 2 / (e - w) * marginScaleX;
		this.scaleY = -2 / (s - n) * marginScaleY;
		this.offsetX = -w * this.scaleX + margin / 256 * marginScaleX;
		this.offsetY = -n * this.scaleY - margin / 256 * marginScaleY;
	}

}

export class GLRenderer {

	protected getContext(options: GLRendererOptions) {
		if(!this.gl) {
			const canvas = document.createElement('canvas');
			canvas.width = options.pixelWidth + this.margin * 2;
			canvas.height = options.pixelHeight + this.margin * 2;

			const gl = canvas.getContext('experimental-webgl')!;

			gl.viewport(0, 0, options.pixelWidth + this.margin * 2, options.pixelHeight + this.margin * 2);
			console.log(gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE));

			gl.clearColor(0, 0, 0, 0.0);
			gl.clearDepth(1);

			// gl.enable(gl.DEPTH_TEST);
			// gl.depthFunc(gl.LEQUAL);
			gl.disable(gl.DEPTH_TEST);
			gl.enable(gl.BLEND);

			this.canvas = canvas;
			this.gl = gl;

try {
			this.shader = new Shader(gl, {
				vertex: pointVertex,
				fragment: pointFragment,
				attributes: {
					[ Attribute.position ]: 'aPosition',
					[ Attribute.weight ]: 'aWeight'
				}
			});
} catch(err) { console.error(err); }
		}

		return(this.gl);
	}

	render(options: GLRendererOptions) {
		const state = new GLRendererState(options, this.margin);
		this.margin = state.pixelRatio * 12;
		const gl = this.getContext(options);

console.log(options);
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		const pointList: Point[] = [];

		for(let LayerFeatures of options.features) {
			for(let feature of LayerFeatures.features) {
				for(let geom of feature.geometries) {
					if(geom instanceof Point) pointList.push(geom);
				}
			}
		}

		const pts = new Float32Array(pointList.length * 3);
		const weights = new Float32Array(pointList.length);

		let p1 = 0, p2 = 0;

		for(let geom of pointList) {
			pts[p1++] = geom.y * state.scaleX + state.offsetX - 1;
			pts[p1++] = geom.x * state.scaleY + state.offsetY + 1;
			pts[p1++] = 0;

			weights[p2++] = (geom as any).count || 1;
		}

		this.shader.activate([]);

		const pointPosBuffer = gl.createBuffer()!;
		gl.bindBuffer(gl.ARRAY_BUFFER, pointPosBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, pts, gl.STATIC_DRAW);
		gl.vertexAttribPointer(Attribute.position, 3, gl.FLOAT, false, 0, 0);

		const pointWeightBuffer = gl.createBuffer()!;
		gl.bindBuffer(gl.ARRAY_BUFFER, pointWeightBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, weights, gl.STATIC_DRAW);
		gl.vertexAttribPointer(Attribute.weight, 1, gl.FLOAT, false, 0, 0);

		const uSize = gl.getUniformLocation(this.shader.program, 'uSize')!;
		const uEdge = gl.getUniformLocation(this.shader.program, 'uEdge')!;
		const uAlpha = gl.getUniformLocation(this.shader.program, 'uAlpha')!;
		const uColor = gl.getUniformLocation(this.shader.program, 'uColor')!;

		let size: number, edge: number;

		gl.uniform1f(uAlpha, 1);
		gl.uniform3f(uColor, 0, 0, 0.5);

		size = 24 * state.pixelRatio;
		edge = (size / 2 - 2) / (size / 2);

		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointList.length);

		size = 16 * state.pixelRatio;
		edge = (size / 2 - 2) / (size / 2);

		gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointList.length);

		gl.uniform1f(uAlpha, 0.125);
		gl.uniform3f(uColor, 0, 0.125, 0.5);

		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointList.length);

		options.canvas.getContext('2d')!.drawImage(this.canvas, -this.margin, -this.margin);
	}

	/** Margin in pixels added around tiles when rendering, because WebGL
	  * omits all symbols with centers outside the viewport. */
	margin: number;
	canvas: HTMLCanvasElement;
	gl: WebGLRenderingContext;
	shader: Shader;

}
