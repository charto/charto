// This file is part of charto-render, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { Point } from 'cgeo';
import { Layer, LayerFeatures } from 'charto-model';
import { RendererOptions, RendererState }from './RendererState';
import { Shader, Attribute } from 'charto-3d';

import * as pointVertex from '../glsl/point.vert';
import * as pointFragment from '../glsl/point.frag';

export interface GLRendererOptions extends RendererOptions {

	canvas: HTMLCanvasElement;

}

export class GLRendererState extends RendererState {

	constructor(options: RendererOptions, margin: number) {
		super();

		const marginScaleX = options.widthPixels / (options.widthPixels + margin * 2);
		const marginScaleY = options.heightPixels / (options.heightPixels + margin * 2);

		const { s, w, n, e } = options.bbox;
		this.pixelRatio = options.pixelRatio || 1;
		this.scaleX = 2 / (e - w) * marginScaleX;
		this.scaleY = -2 / (s - n) * marginScaleY;
		this.offsetX = -w * this.scaleX + margin / 256 * marginScaleX;
		this.offsetY = -n * this.scaleY - margin / 256 * marginScaleY;
	}

}

export class GLRenderer {

	private createContext() {
		const gl = this.canvas.getContext('experimental-webgl')!;

		gl.clearColor(0, 0, 0, 0.0);
		gl.clearDepth(1);

		// gl.enable(gl.DEPTH_TEST);
		// gl.depthFunc(gl.LEQUAL);
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);

		this.shader = new Shader(gl, {
			vertex: pointVertex,
			fragment: pointFragment,
			attributes: {
				[ Attribute.position ]: 'aPosition',
				[ Attribute.weight ]: 'aWeight'
			}
		});

		this.bucketCount = this.bucketsPerSide * this.bucketsPerSide;

		this.pointPosBuffer = gl.createBuffer()!;
		this.pointWeightBuffer = gl.createBuffer()!;

		const pts = new Float32Array(this.bucketCount * 3);
		const weights = new Float32Array(this.bucketCount);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointPosBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, pts, gl.STREAM_DRAW);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointWeightBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, weights, gl.STREAM_DRAW);

		return(gl);
	}

	protected getContext(options: GLRendererOptions) {
		const widthPixels = options.widthPixels + this.margin * 2;
		const heightPixels = options.heightPixels + this.margin * 2;
		let gl = this.gl;

		if(!this.canvas) this.canvas = document.createElement('canvas');

		if(this.widthPixels != widthPixels || this.heightPixels != heightPixels) {
			this.canvas.width = widthPixels;
			this.canvas.height = heightPixels;

			if(!gl) {
				gl = this.createContext();
				this.gl = gl;

				console.log(gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE));
			}

			gl.viewport(0, 0, widthPixels, heightPixels);

			this.widthPixels = widthPixels;
			this.heightPixels = heightPixels;
		}

		return(gl);
	}

	render(options: GLRendererOptions) {
		const state = new GLRendererState(options, this.margin);
		this.margin = state.pixelRatio * 12;
		const gl = this.getContext(options);

		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		const pointList: Point[] = [];

		for(let LayerFeatures of options.features) {
			for(let feature of LayerFeatures.features) {
				for(let geom of feature.childList) {
					if(geom instanceof Point) pointList.push(geom);
				}
			}
		}

		if(!pointList.length) return;

		let pointCount = pointList.length;
		const bufferSize = Math.min(this.bucketCount, pointCount);
		const pts = new Float32Array(bufferSize * 3);
		const weights = new Float32Array(bufferSize);

		let p1 = 0, p2 = 0;

		if(pointCount > bufferSize) {
			const { s, w, n, e } = options.bbox;
			const scaleX = this.bucketsPerSide / (n - s);
			const scaleY = this.bucketsPerSide / (e - w);
			const indexGrid: number[] = new Array(this.bucketCount);
			let index: number;
			let pos: number;
			let x: number;
			let y: number;

			for(let geom of pointList) {
				x = ~~((geom.x - s) * scaleX);
				y = ~~((geom.y - w) * scaleY);
				pos = y * this.bucketsPerSide + x;

				index = indexGrid[pos];

				if(!index) {
					index = ++p2;

					pts[p1++] = geom.x;
					pts[p1++] = geom.y;
					pts[p1++] = 1;

					weights[index - 1] = 0;
					indexGrid[pos] = index;
				}

				weights[index - 1] += geom.weight || 1;
			}
		} else {
			for(let geom of pointList) {
				pts[p1++] = geom.x;
				pts[p1++] = geom.y;
				pts[p1++] = 1;

				weights[p2++] = geom.weight || 1;
			}
		}

		pointCount = p2;

		this.shader.activate();

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointPosBuffer);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, pts);
		gl.vertexAttribPointer(Attribute.position, 3, gl.FLOAT, false, 0, 0);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointWeightBuffer);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, weights);
		gl.vertexAttribPointer(Attribute.weight, 1, gl.FLOAT, false, 0, 0);

		const [ uSize, uEdge, uAlpha, uColor, uTransform ] = this.shader.getUniformLocations([
			'uSize', 'uEdge', 'uAlpha', 'uColor', 'uTransform'
		]);

		let size: number, edge: number;

		gl.uniform1f(uAlpha, 1);
		gl.uniform3f(uColor, 0, 0, 0.5);

		gl.uniformMatrix3fv(
			uTransform,
			false,
			[
				0, state.scaleX, 0,
				state.scaleY, 0, 0,
				state.offsetX - 1, state.offsetY + 1, 0
			]
		);

		size = 24 * state.pixelRatio;
		edge = (size / 2 - 2) / (size / 2);

		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointCount);

		size = 20 * state.pixelRatio;
		edge = (size / 2 - 2) / (size / 2);

		gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointCount);

		gl.uniform1f(uAlpha, 0.125);
		gl.uniform3f(uColor, 0, 0.125, 0.5);

		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointCount);

		options.canvas.getContext('2d')!.drawImage(this.canvas, -this.margin, -this.margin);
	}

	widthPixels: number;
	heightPixels: number;

	/** Margin in pixels added around tiles when rendering, because WebGL
	  * omits all symbols with centers outside the viewport. */
	margin: number;
	canvas: HTMLCanvasElement;
	gl: WebGLRenderingContext;
	shader: Shader;
	pointPosBuffer: WebGLBuffer;
	pointWeightBuffer: WebGLBuffer;
	bucketsPerSide = 64;
	bucketCount: number;

}
