// This file is part of charto-render, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { Point } from 'cgeo';
import { Layer, LayerFeatures } from 'charto-model';
import { RendererOptions, RendererState }from './RendererState';
import { Shader, Attribute } from 'charto-3d';

import * as pointVertex from '../glsl/point.vert';
import * as pointFragment from '../glsl/point.frag';

export interface GLRendererOptions extends RendererOptions {

	canvas: HTMLCanvasElement;

}

export class GLRendererState extends RendererState {

	constructor(public options: RendererOptions, maxRadius: number, maxPointSize: number) {
		super();

		// If point size is too large for the GPU, a margin for points centered
		// outside the viewport is unnecessary because quads are drawn instead.
		if(maxRadius * 2 > maxPointSize) maxRadius = 0;

		this.pixelRatio = options.pixelRatio || 1;
		const margin = this.pixelRatio * maxRadius;

		this.fullWidthPixels = options.widthPixels + margin * 2;
		this.fullHeightPixels = options.heightPixels + margin * 2;

		const marginScaleX = options.widthPixels / this.fullWidthPixels;
		const marginScaleY = options.heightPixels / this.fullHeightPixels;

		const { s, w, n, e } = options.bbox;

		this.margin = margin;
		this.scaleX = 2 / (e - w) * marginScaleX;
		this.scaleY = -2 / (s - n) * marginScaleY;
		this.offsetX = margin * 2 / this.fullWidthPixels - 1;
		this.offsetY = 1 - margin * 2 / this.fullHeightPixels;
	}

	/** Margin in pixels added around tiles when rendering, because WebGL
	  * renders no gl.POINTS centered outside the viewport. */
	margin: number;

	/** Display tile width in pixels, including margins. */
	fullWidthPixels: number;
	/** Display tile height in pixels, including margins. */
	fullHeightPixels: number;

}

export class GLRenderer {

	private createContext() {
		const gl = this.canvas.getContext('experimental-webgl')!;

		gl.clearColor(0, 0, 0, 0.0);
		gl.clearDepth(1);

		// gl.enable(gl.DEPTH_TEST);
		// gl.depthFunc(gl.LEQUAL);
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);

		[ this.minPointSize, this.maxPointSize ] = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);

		this.shader = new Shader(gl, {
			vertex: pointVertex,
			fragment: pointFragment,
			attributes: {
				[ Attribute.position ]: 'aPosition',
				[ Attribute.weight ]: 'aWeight'
			}
		});

		this.bucketCount = this.bucketsPerSide * this.bucketsPerSide;

		this.pointPosBuffer = gl.createBuffer()!;
		this.pointWeightBuffer = gl.createBuffer()!;

		const pts = new Float32Array(this.bucketCount * 3);
		const weights = new Float32Array(this.bucketCount);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointPosBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, pts, gl.STREAM_DRAW);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointWeightBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, weights, gl.STREAM_DRAW);

		return(gl);
	}

	protected getContext(state: GLRendererState) {
		const options = state.options;
		const widthPixels = state.fullWidthPixels;
		const heightPixels = state.fullHeightPixels;
		let gl = this.gl;

		if(!this.canvas) this.canvas = document.createElement('canvas');

		if(this.widthPixels != widthPixels || this.heightPixels != heightPixels) {
			this.canvas.width = widthPixels;
			this.canvas.height = heightPixels;

			if(!gl) {
				gl = this.createContext();
				this.gl = gl;
			}

			gl.viewport(0, 0, widthPixels, heightPixels);

			this.widthPixels = widthPixels;
			this.heightPixels = heightPixels;
		}

		return(gl);
	}

	render(options: GLRendererOptions) {
		const maxRadius = 12;
		const state = new GLRendererState(options, maxRadius, this.maxPointSize);
		const gl = this.getContext(state);

		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		const pointList: Point[] = [];

		for(let LayerFeatures of options.features) {
			for(let feature of LayerFeatures.features) {
				for(let geom of feature.childList) {
					if(geom instanceof Point) pointList.push(geom);
				}
			}
		}

		if(!pointList.length) return;

		let pointCount = pointList.length;
		const bufferSize = Math.min(this.bucketCount, pointCount);
		const pts = new Float32Array(bufferSize * 3);
		const weights = new Float32Array(bufferSize);

		let p1 = 0, p2 = 0;

		const { s, w, n, e } = options.bbox;

		if(pointCount > bufferSize) {
			// If there are too many points to draw, group them to buckets on
			// a regular grid. Draw bucket contents at the first member point
			// for a nicer, slightly irregular grid.
			// Point weight is a sum of bucket contents, for setting opacity
			// to match separately drawn overlapping points.

			const scaleX = this.bucketsPerSide / (n - s);
			const scaleY = this.bucketsPerSide / (e - w);
			const indexGrid: number[] = new Array(this.bucketCount);
			let index: number;
			let pos: number;
			let x: number;
			let y: number;

			for(let geom of pointList) {
				x = ~~((geom.x - s) * scaleX);
				y = ~~((geom.y - w) * scaleY);
				pos = y * this.bucketsPerSide + x;

				index = indexGrid[pos];

				if(!index) {
					index = ++p2;

					pts[p1++] = geom.x - n;
					pts[p1++] = geom.y - w;
					pts[p1++] = 1;

					weights[index - 1] = 0;
					indexGrid[pos] = index;
				}

				weights[index - 1] += geom.weight || 1;
			}
		} else {
			for(let geom of pointList) {
				pts[p1++] = geom.x - n;
				pts[p1++] = geom.y - w;
				pts[p1++] = 1;

				weights[p2++] = geom.weight || 1;
			}
		}

		pointCount = p2;

		if(maxRadius * 2 > this.maxPointSize) {
			// TODO: Points are too large for the GPU.
			// Draw quads instead and use a different vertex shader.
		}

		this.shader.activate();

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointPosBuffer);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, pts);
		gl.vertexAttribPointer(Attribute.position, 3, gl.FLOAT, false, 0, 0);

		gl.bindBuffer(gl.ARRAY_BUFFER, this.pointWeightBuffer);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, weights);
		gl.vertexAttribPointer(Attribute.weight, 1, gl.FLOAT, false, 0, 0);

		const [ uSize, uEdge, uAlpha, uColor, uTransform ] = this.shader.getUniformLocations([
			'uSize', 'uEdge', 'uAlpha', 'uColor', 'uTransform'
		]);

		gl.uniformMatrix3fv(
			uTransform,
			false,
			[
				0, state.scaleX, 0,
				state.scaleY, 0, 0,
				state.offsetX, state.offsetY, 0
			]
		);

		let size: number, edge: number;

		// Draw opaque outer edge of points.

		gl.uniform1f(uAlpha, 1);
		gl.uniform3f(uColor, 0, 0, 0.5);

		size = 24 * state.pixelRatio;
		edge = (size / 2 - 2) / (size / 2);

		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointCount);

		// Clear inside of points for translucent fill.

		size = 20 * state.pixelRatio;
		edge = (size / 2 - 2) / (size / 2);

		gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointCount);

		// Draw translucent fill inside points.

		gl.uniform1f(uAlpha, 0.125);
		gl.uniform3f(uColor, 0, 0.125, 0.5);

		gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.uniform1f(uSize, size);
		gl.uniform1f(uEdge, edge * edge);
		gl.drawArrays(gl.POINTS, 0, pointCount);

		// Blit OpenGL canvas into target tile.

		options.canvas.getContext('2d')!.drawImage(this.canvas, -state.margin, -state.margin);
	}

	/** Current canvas and viewport width in pixels, including margins. */
	widthPixels: number;
	/** Current canvas and viewport height in pixels, including margins. */
	heightPixels: number;

	/** Minimum gl.POINTS width / height for GPU in pixels, reported by WebGL. */
	minPointSize: number;
	/** Maximum gl.POINTS width / height for GPU in pixels, reported by WebGL. */
	maxPointSize: number;

	canvas: HTMLCanvasElement;
	gl: WebGLRenderingContext;
	shader: Shader;
	pointPosBuffer: WebGLBuffer;
	pointWeightBuffer: WebGLBuffer;

	/** Grid cells across each dimension for grouping excessive points.
	  * 128 buckets for 256-pixel tiles mean 2-pixel cells.
	  * Fewer buckets cause display artifacts. */
	bucketsPerSide = 128;

	/** Total grid cells for grouping points. Square of bucketsPerSide. */
	bucketCount: number;

}
