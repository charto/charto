// This file is part of geotree, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as cgeo from 'cgeo';
import { QuadTree, QuadTreeOptions } from './QuadTree';
import { TileClass } from './QuadTile';
import { GeoTile, NearestState } from './GeoTile';

export interface GeoTreeOptions extends QuadTreeOptions {
	pointsPerTile?: number;
}

export class GeoTree<Tile extends GeoTile = GeoTile> extends QuadTree<Tile> {

	constructor(
		options: GeoTreeOptions,
		Tile = GeoTile as TileClass<Tile>
	) {
		const { pointsPerTile } = options;

		super(options, Tile);

		this.pointsPerTile = pointsPerTile || 4096;
	}

	/** @param x Northing. */
	/** @param y Easting. */

	findNearest(x: number, y: number, s = this.s, w = this.w, n = this.n, e = this.e, root?: Tile) {
		const state: NearestState = { x, y, s, w, n, e, result: null, dist: Infinity };

		const result = this.iterate(
			(tile: Tile) => tile.findNearest(state),
			null,
			s, w, n, e,
			root
		).then(() => state.result);

		return(result);
	}

	insertGeometry(
		geom: cgeo.Geometry,
		touchedTileList?: Tile[],
		isSurface?: boolean,
		shape?: cgeo.Curve | cgeo.Surface
	) {
		switch(geom.kind) {
			case cgeo.GeometryKind.point:
				this.root.insertPoint(geom as cgeo.Point, touchedTileList);
				return;

			case cgeo.GeometryKind.lineString:
			case cgeo.GeometryKind.circularString:
				// Polyline or polygon edge
				this.root.insertCurve(
					geom as cgeo.String,
					0,
					(geom as cgeo.String).x.length - 1,
					isSurface || false,
					shape || geom,
					touchedTileList
				);
				return;
		}

		if(!shape) {
			if(geom instanceof cgeo.Surface) {
				isSurface = true;
				shape = geom;
			} else if(geom instanceof cgeo.Curve) {
				shape = geom;
			}
		}

		for(let child of (geom as cgeo.GeometryCollection).childList || []) {
			this.insertGeometry(child, touchedTileList, isSurface);
		}
	}

	pointsPerTile: number;

}
