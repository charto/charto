// This file is part of geotree, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { Point, LineString } from 'cgeo';
import { BBox, BBoxLike } from 'charto-types';

import { QuadTile, QuadPos } from './QuadTile';
import { GeoTree } from './GeoTree';

/** Reference to part of a polyline.
  * For polygons sharing an edge, sometimes first > last. */

export interface LineStringRef {
	line: LineString;
	/** Index of starting point along the line string. */
	first?: number;
	/** Index of end point along the line string. */
	last?: number;
}

export interface TileGeometry {
	pointList?: Point[];
	lineList?: LineStringRef[];
	/** Polygons reference border segments, TopoJSON-style. */
	polygonList?: LineStringRef[][];
}

/** State during search for content nearest to a point. */

export interface NearestState {
	x: number;
	y: number;
	s: number;
	w: number;
	n: number;
	e: number;
	result: any;
	/** Squared distance (or other distance for a custom implementation). */
	dist: number;
}

export class GeoTile extends QuadTile implements BBoxLike, TileGeometry {

	addPoint(pt: Point) {
		this.pointList.push(pt);
		++this.pointCount;
	}

	addLine(line: LineString, first = 0, last = line.x.length - 1) {
		this.lineList.push({ line, first, last });
		this.pointCount += last - first + 1;
	}

	getGeometry() {
		return({
			then: (fn: (geometry: TileGeometry) => any) => fn(this)
		} as Promise<TileGeometry>);
	}

	findNearest(state: NearestState) {
		let px: number, py: number;
		let dist: number;
		let { x, y } = state;

		// Bail out if entire tile is further away than closest point found so far.
		if(this.sqDistTo(x, y) > state.dist) return(false);

		let { n, w, s, e } = state;

		const result = this.getGeometry().then((geom: TileGeometry) => {
			for(let pt of geom.pointList || []) {
				px = pt.x;
				py = pt.y;

				if(px >= s && py >= w && px <= n && py <= e) {
					px -= x;
					py -= y;

					dist = px * px + py * py;
					if(dist < state.dist) {
						state.result = pt;
						state.dist = dist;
					}
				}
			}
		});

		if(!result || typeof(result) != 'object' || typeof(result.then) != 'function') {
			return(state.result);
		}

		return(result.then(() => state.result));
	}

	split() {
		super.split();

		const swChild = this.childList![QuadPos.SW]!;
		const ns = swChild.n;
		const ew = swChild.e;

		let pos: QuadPos;

		for(let pt of this.pointList) {
			pos = QuadPos.SW;
			if(pt.x >= ns) pos += (QuadPos.NW - QuadPos.SW);
			if(pt.y >= ew) pos += (QuadPos.SE - QuadPos.SW);

			this.childList![pos]!.addPoint(pt);
		}

		if(this.pointCount) {
			this.pointCount = 0;
			this.pointList = [];
			this.lineList = [];
		}
	}

	sqDistTo: (lat: number, lon: number) => number;

	/** Total number of points and line string waypoints. */
	pointCount = 0;
	pointList: Point[] = [];
	/** Weight of each point, useful for clustering. */
	pointWeightList?: number[];

	lineList: LineStringRef[] = [];

	tree: GeoTree;

}

GeoTile.prototype.sqDistTo = BBox.sqDistTo;
