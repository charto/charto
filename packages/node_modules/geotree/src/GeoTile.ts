// This file is part of geotree, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as cgeo from 'cgeo';
import { detSign } from 'cmath';
import { BBox, BBoxLike } from 'charto-types';

import { QuadTile, QuadPos } from './QuadTile';
import { GeoTree } from './GeoTree';

/** Reference to part of a polyline.
  * For polygons sharing an edge, sometimes first > last. */

export interface StringRef {
	curve: cgeo.String;
	/** Index of starting point along the line string. */
	first?: number;
	/** Index of end point along the line string. */
	last?: number;
}

export interface TileGeometry {
	pointList?: cgeo.Point[];
	curveList?: StringRef[][];
	/** Polygons reference border segments, TopoJSON-style. */
	surfaceList?: StringRef[][];
}

/** State during search for content nearest to a point. */

export interface NearestState extends BBoxLike {
	x: number;
	y: number;
	result: any;
	/** Squared distance (or other distance for a custom implementation). */
	dist: number;
}

export class GeoTile extends QuadTile implements BBoxLike, TileGeometry {

	/** Insert point into sub-quadtree rooted at this tile.
	  * @return Quadtree leaf tile where point was inserted. */

	insertPoint(geom: cgeo.Point, touchedTileList?: GeoTile[]) {
		let tile = this;
		let childList: typeof tile.childList;
		let child: GeoTile;
		let ns: number;
		let ew: number;
		let pos: QuadPos;

		while(1) {
			childList = tile.childList;

			if(!childList) {
				if(tile.pointCount >= this.tree.pointsPerTile) {
					childList = tile.split();
				} else {
					break;
				}
			}

			child = childList[QuadPos.SW]!;
			ns = child.n;
			ew = child.e;

			pos = QuadPos.SW;
			if(geom.x >= ns) pos += (QuadPos.NW - QuadPos.SW);
			if(geom.y >= ew) pos += (QuadPos.SE - QuadPos.SW);

			tile = childList[pos]!;
		}

		tile.pointList.push(geom);
		++tile.pointCount;

		if(touchedTileList) touchedTileList.push(tile);
	}

	testCorner(outer: QuadPos, inner: QuadPos, x1: number, y1: number, x2: number, y2: number) {
		const ns = this.n - this.s;
		const ew = this.e - this.w;
		const x = this.n - ((outer ^ (outer >> 1)) & 1 ? ns >> 1 : 0) - ((inner ^ (inner >> 1)) & 1 ? ns >> 1 : 0);
		const y = this.w + ((outer >> 1) & 1 ? ew >> 1 : 0) + ((inner >> 1) & 1 ? ew >> 1 : 0);

		return(detSign(x2 - x1, y2 - y1, x - x1, y - y1));
	}

	insertCurveAdjacent(
		geom: cgeo.String,
		first: number,
		last: number,
		pos1: QuadPos,
		pos2: QuadPos,
		sign: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		const x1 = geom.x[first];
		const y1 = geom.y[first];
		const x2 = geom.x[last];
		const y2 = geom.y[last];

		/** Line segment source quadrant inside tile. */
		const quad1 = (0xc9 >>> (pos1 * 2)) & 3;

		/** Line segment destination quadrant inside tile,
		 * relative to source quadrant. */
		let quad2 = (0xc9 >>> (pos2 * 2)) - quad1 & 3;

		const region = this.getRegion(x2, y2);

		/** Line segment destination octant outside tile,
		 * relative to source quadrant. */
		const octant2 = (0x80c0405e >>> ((region ^ 3) * 2)) - quad1 * 2 & 7;

		if(quad2 != 2) {
			sign = (quad2 & 2) | (octant2 & 4) ? -1 : 1;
		}

		if(
			(quad2 != 2 && octant2 == quad2 + 2) ||
			this.testCorner(
				quad1 + (quad2 == 2 ? 2 : 0),
				quad1 + sign,
				x1, y1,
				x2, y2
			) * sign > 0
		) {
			const pos = (0xd2 >>> ((quad1 + quad2 & 3) * 2)) & 3;
			this.childList![pos]!.insertCurveCrossing(geom, first, last, isSurface, touchedTileList);
		}
	}

	insertCurveCrossing(
		geom: cgeo.String,
		first: number,
		last: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		let childList = this.childList;

		if(childList) {
			for(let child of childList) {
				if(child!.intersectsLine(geom.x[first], geom.y[first], geom.x[last], geom.y[last])) {
					child!.insertCurveCrossing(geom, first, last, isSurface, touchedTileList);
				}
			}
		} else {
			this.insertCurve(geom, first, last, isSurface, touchedTileList);
		}
	}

	insertCurve(
		geom: cgeo.String,
		first: number,
		last: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		let childList = this.childList;
		let pos: QuadPos | undefined;
		let x: number | undefined;
		let y: number | undefined;
		let num = first;

		if(childList) {
			const child = childList[QuadPos.SW]!;
			const ns = child.n;
			const ew = child.e;
			let posNext: QuadPos;
			let posPrev: typeof pos;
			let xPrev: typeof x;
			let yPrev: typeof y;
			let outside: boolean | undefined;
			let sign = 0;

			if(num > 0) --num;

			do {
				xPrev = x;
				yPrev = y;
				x = geom.x[num];
				y = geom.y[num];

				posPrev = pos;
				pos = QuadPos.SW;
				if(x >= ns) pos += (QuadPos.NW - QuadPos.SW);
				if(y >= ew) pos += (QuadPos.SE - QuadPos.SW);

				if(num > first || (num == first && first > 0)) {
					// If tiles were crossed diagonally, handle adjacent tile along the way.
					if((pos ^ posPrev!) == 3) {
						const quad = (0xc9 >>> (pos * 2)) & 3;
						sign = detSign(x - xPrev!, y - yPrev!, x - ns, y - ew) > 0 ? 1 : -1;

						posNext = (0xd2 >>> ((quad - sign & 3) * 2)) & 3;

						childList[posNext]!.insertCurveCrossing(geom, num - 1, num, isSurface, touchedTileList);
					}
				}

				if(num == first && outside && pos != posPrev) {
					this.insertCurveAdjacent(geom, num, num - 1, pos, posPrev!, -sign, isSurface, touchedTileList);
				}

				outside = (
					x < this.s ||
					y < this.w ||
					x >= this.n ||
					y >= this.e
				);

				if(num > first && outside) break;

				if(num < first) ++num;
				else num = childList[pos]!.insertCurve(geom, num, last, isSurface, touchedTileList);
			} while(num <= last);

			if(num > first && num <= last && pos != posPrev) {
				this.insertCurveAdjacent(geom, num - 1, num, posPrev!, pos, sign, isSurface, touchedTileList);
			}
		} else {
			do {
				x = geom.x[num];
				y = geom.y[num];
			} while(
				x >= this.s &&
				y >= this.w &&
				x < this.n &&
				y < this.e &&
				num++ < last
			);

			if(last > num) last = num;

			this.curveList.push([{ curve: geom, first, last }]);
			this.pointCount += last - first + 1;

			if(touchedTileList) touchedTileList.push(this);
		}

		return(num);
	}

	getGeometry() {
		return({
			then: (fn: (geometry: TileGeometry) => any) => fn(this)
		} as Promise<TileGeometry>);
	}

	findNearest(state: NearestState) {
		let px: number, py: number;
		let dist: number;
		let { x, y } = state;

		// Bail out if entire tile is further away than closest point found so far.
		if(this.sqDistTo(x, y) > state.dist) return(false);

		let { n, w, s, e } = state;

		const result = this.getGeometry().then((geom: TileGeometry) => {
			for(let pt of geom.pointList || []) {
				px = pt.x;
				py = pt.y;

				if(px >= s && py >= w && px <= n && py <= e) {
					px -= x;
					py -= y;

					dist = px * px + py * py;
					if(dist < state.dist) {
						state.result = pt;
						state.dist = dist;
					}
				}
			}
		});

		if(!result || typeof(result) != 'object' || typeof(result.then) != 'function') {
			return(state.result);
		}

		return(result.then(() => state.result));
	}

	split() {
		const childList = super.split();

		for(let geom of this.pointList) {
			this.insertPoint(geom);
		}

		for(let ref of this.curveList) {
			// this.insertCurve(...);
		}

		if(this.pointCount) {
			this.pointCount = 0;
			this.pointList = [];
			this.curveList = [];
		}

		return(childList);
	}

	/** Commit changes to a subtree.
	  * Useful when data is not only stored in memory.
	  * Subclassed methods could use exportPak to serialize the contents. */

	commit() {
		for(let child of this.childList || []) {
			child!.commit();
		}
	}

	summarize() {
		if(!this.childList) return;

		const { s, w, n, e } = this;
		const scaleX = 64 / (n - s);
		const scaleY = 64 / (e - w);
		const indexGrid: number[] = new Array(64 * 64);
		let index: number;
		let pos: number;
		let x: number;
		let y: number;

		this.pointWeightList = [];

		for(let child of this.childList) {
			if(!child) continue;

			child.summarize();

			let childWeightList = child.pointWeightList || [];
			let childPointNum = 0;

			for(let geom of child.pointList) {
				x = ~~((geom.x - s) * scaleX);
				y = ~~((geom.y - w) * scaleY);
				pos = y * 64 + x;

				index = indexGrid[pos];

				if(!index) {
					index = this.pointList.length + 1;
					this.pointList[index - 1] = geom;
					this.pointWeightList[index - 1] = 0;
					indexGrid[pos] = index;
					++this.pointCount;
				}

				this.pointWeightList[index - 1] += childWeightList[childPointNum++] || geom.weight || 1;
			}
		}
	}

	sqDistTo: (x: number, y: number) => number;
	getRegion: (x: number, y: number) => number;
	intersectsLine: (x1: number,y1: number,x2: number,y2: number) => boolean;

	/** Total number of points, including those defining curves and polygon edges. */
	pointCount = 0;
	pointList: cgeo.Point[] = [];
	/** Weight of each point, useful for clustering. */
	pointWeightList?: number[];

	curveList: StringRef[][] = [];

	tree: GeoTree;

}

GeoTile.prototype.sqDistTo = BBox.sqDistTo;
GeoTile.prototype.getRegion = BBox.getRegion;
GeoTile.prototype.intersectsLine = BBox.intersectsLine;
