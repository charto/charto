// This file is part of geotree, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import * as cgeo from 'cgeo';
import { detSign } from 'cmath';
import { BBox, BBoxLike } from 'charto-types';

import { QuadTile, QuadPos } from './QuadTile';
import { GeoTree } from './GeoTree';

/** Reference to part of a polyline.
  * For polygons sharing an edge, sometimes first > last. */

export interface StringRef {
	curve: cgeo.String;
	/** Index of starting point along the line string. */
	first?: number;
	/** Index of end point along the line string. */
	last?: number;
}

export interface TileGeometry {
	pointList?: cgeo.Point[];
	curveList?: StringRef[][];
	/** Polygons reference border segments, TopoJSON-style. */
	surfaceList?: StringRef[][];
}

/** State during search for content nearest to a point. */

export interface NearestState extends BBoxLike {
	x: number;
	y: number;
	result: any;
	/** Squared distance (or other distance for a custom implementation). */
	dist: number;
}

export class GeoTile extends QuadTile implements BBoxLike, TileGeometry {

	/** Insert point into sub-quadtree rooted at this tile.
	  * @return Quadtree leaf tile where point was inserted. */

	insertPoint(geom: cgeo.Point, touchedTileList?: GeoTile[]) {
		let tile = this;
		let childList: typeof tile.childList;
		let child: GeoTile;
		let ns: number;
		let ew: number;
		let pos: QuadPos;

		while(1) {
			childList = tile.childList;

			if(!childList) {
				if(tile.pointCount >= this.tree.pointsPerTile) {
					childList = tile.split();
				} else {
					break;
				}
			}

			child = childList[QuadPos.SW]!;
			ns = child.n;
			ew = child.e;

			pos = QuadPos.SW;
			if(geom.x >= ns) pos += (QuadPos.NW - QuadPos.SW);
			if(geom.y >= ew) pos += (QuadPos.SE - QuadPos.SW);

			tile = childList[pos]!;
		}

		tile.pointList.push(geom);
		++tile.pointCount;

		if(touchedTileList) touchedTileList.push(tile);
	}

	private testCorner(outer: QuadPos, inner: QuadPos, x1: number, y1: number, x2: number, y2: number) {
		const ns = this.n - this.s;
		const ew = this.e - this.w;
		const x = this.n - ((outer ^ (outer >> 1)) & 1 ? ns >> 1 : 0) - ((inner ^ (inner >> 1)) & 1 ? ns >> 1 : 0);
		const y = this.w + ((outer >> 1) & 1 ? ew >> 1 : 0) + ((inner >> 1) & 1 ? ew >> 1 : 0);

		return(detSign(x2 - x1, y2 - y1, x - x1, y - y1));
	}

	private insertCurveLeaf(
		geom: cgeo.String,
		first: number,
		last: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		let num = first;
		let x: number;
		let y: number;

		do {
			x = geom.x[num];
			y = geom.y[num];
		} while(
			x >= this.s &&
			y >= this.w &&
			x < this.n &&
			y < this.e &&
			num++ < last
		);

		if(last > num) last = num;

		this.curveList.push([{ curve: geom, first, last }]);
		this.pointCount += last - first + 1;

		if(touchedTileList) touchedTileList.push(this);

		return(num);
	}

	/** Insert a line segment if it crosses this tile (based on which side one
	  * of the tile corners falls on).
	  *
	  * @param geom Polyline containing segment to insert.
	  * @param first Segment start index.
	  * @param last Segment end index.
	  * @param pos1 Child tile number (quadrant) where segment starts.
	  * @param pos1 Child tile number (quadrant) where segment ends.
	  * @param sign Which side of the segment the tile center falls on (1 or -1).
	  * @param isSurface Flag whether the curve is the edge of a surface.
	  * @param touchedTileList If given, this tile is pushed here if modified. */

	private insertCurveAdjacent(
		geom: cgeo.String,
		first: number,
		last: number,
		pos1: QuadPos,
		pos2: QuadPos,
		sign: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		const x1 = geom.x[first];
		const y1 = geom.y[first];
		const x2 = geom.x[last];
		const y2 = geom.y[last];

		/** Line segment source quadrant (from tile center). */
		const quad1 = (0xc9 >>> (pos1 * 2)) & 3;

		/** Line segment destination quadrant (from tile center),
		  * numbered counter-clockwise relative to source quadrant. */
		let quad2 = (0xc9 >>> (pos2 * 2)) - quad1 & 3;

		const region = this.getRegion(x2, y2);

		/** Line segment destination octant outside tile,
		  * relative to source quadrant. */
		const octant2 = (0x80c0405e >>> ((region ^ 3) * 2)) - quad1 * 2 & 7;

		// If source and destination quadrant are not opposite,
		// corner to test is in the source quadrant.
		if(quad2 != 2) {
			sign = (quad2 & 2) | (octant2 & 4) ? -1 : 1;
		}

		if(
			(quad2 != 2 && octant2 == quad2 + 2) ||
			this.testCorner(
				// Test a corner from the first quadrant,
				// unless the second quadrant is opposite it.
				quad1 + (quad2 == 2 ? 2 : 0),
				// For opposite quadrants, corner to test depends on tile
				// center. Otherwise it depends on destination quadrant and
				// octant (see above).
				quad1 + sign,
				x1, y1,
				x2, y2
			) * sign > 0
		) {
			const pos = (0xd2 >>> ((quad1 + quad2 & 3) * 2)) & 3;
			this.childList![pos]!.insertCurveCrossing(geom, first, last, isSurface, touchedTileList);
		}
	}

	/** Insert a line segment crossing this tile,
	  * without endpoints actually inside. */

	private insertCurveCrossing(
		geom: cgeo.String,
		first: number,
		last: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		let childList = this.childList;

		if(!childList) {
			return(this.insertCurveLeaf(geom, first, last, isSurface, touchedTileList));
		}

		for(let child of childList) {
			if(child!.intersectsLine(geom.x[first], geom.y[first], geom.x[last], geom.y[last])) {
				child!.insertCurveCrossing(geom, first, last, isSurface, touchedTileList);
			}
		}
	}

	/** Insert a polyline into this tile, split so that children will contain
	  * only the part intersecting them. The first point may be outside this
	  * tile if it starts the polyline. The second must be inside and insertion
	  * stops at any following point outside this tile.
	  *
	  * @param geom Polyline to insert.
	  * @param first Index of first point to insert.
	  * @param last Index of last point to insert. Insertion may stop earlier.
	  * @param isSurface Flag whether the curve is the edge of a surface.
	  * @param touchedTileList If given, any tiles modified are pushed here.
	  * @return One past the index of the last actually inserted point
	  * (index of the first remaining point not inside this tile, if any). */

	insertCurve(
		geom: cgeo.String,
		first: number,
		last: number,
		isSurface: boolean,
		touchedTileList?: GeoTile[]
	) {
		let childList = this.childList;

		// If no child tiles exist, start inserting points while they're
		// inside. Index to the first point outside this tile (one past the
		// last inserted point) is passed back to the caller.
		if(!childList) {
			return(this.insertCurveLeaf(geom, first, last, isSurface, touchedTileList));
		}

		let num = first;

		let x: number | undefined;
		let y: number | undefined;
		let xPrev: typeof x;
		let yPrev: typeof y;

		const child = childList[QuadPos.SW]!;
		const ns = child.n;
		const ew = child.e;

		let pos: QuadPos | undefined;
		let posPrev: typeof pos;
		let posNext: QuadPos;

		let outside: boolean | undefined;
		let sign = 0;

		// If a previous point exists along the polyline, it's probably outside
		// this tile. Start from it to handle the incoming line segment.
		if(num > 0) --num;

		do {
			// Read point coordinates.
			xPrev = x;
			yPrev = y;
			x = geom.x[num];
			y = geom.y[num];

			// Get child tile number (quadrant) this point belongs to.
			posPrev = pos;
			pos = QuadPos.SW;
			if(x >= ns) pos += (QuadPos.NW - QuadPos.SW);
			if(y >= ew) pos += (QuadPos.SE - QuadPos.SW);

			// Points after the first define line segments.
			if(num > first || (num == first && first > 0)) {
				// If child tiles were crossed diagonally,
				// handle the adjacent tile intersected by the line.
				if((pos ^ posPrev!) == 3) {
					// Get quadrant number in counter-clockwise order.
					const quad = (0xc9 >>> (pos * 2)) & 3;
					// Which side of this tile's center did the line pass?
					sign = detSign(x - xPrev!, y - yPrev!, x - ns, y - ew) > 0 ? 1 : -1;

					// Get number of the adjacent tile on the same side.
					posNext = (0xd2 >>> ((quad - sign & 3) * 2)) & 3;

					// Insert segment to intersected tile.
					childList[posNext]!.insertCurveCrossing(geom, num - 1, num, isSurface, touchedTileList);
				}

				// If the first point to insert was preceded by one outside this
				// tile and within a different quadrant (from this tile's center),
				// the incoming line segment may intersect the child tile in the
				// previous quadrant. Handle it.
				if(num == first && outside && pos != posPrev) {
					this.insertCurveAdjacent(geom, num, num - 1, pos, posPrev!, -sign, isSurface, touchedTileList);
				}
			}

			outside = (
				x < this.s ||
				y < this.w ||
				x >= this.n ||
				y >= this.e
			);

			// Stop if a point other than the first is outside this tile.
			// The polyline continues to a different subtree of this quadtree.
			if(num > first && outside) break;

			if(num < first) {
				// If still handling a possible incoming line segment, move to
				// the first point to insert.
				++num;
			} else {
				// Insert points into a child tile while they're inside it.
				// First point outside the child is handled back in this loop
				// (this call can jump ahead any number of points inside the
				// same quadrant).
				num = childList[pos]!.insertCurve(geom, num, last, isSurface, touchedTileList);
			}
		} while(num <= last);

		// If there remains a point outside this tile and in a different
		// quadrant (from this tile's center) than the previous point inside,
		// the outgoing line segment may intersect the child tile in the
		// previous quadrant. Handle it.
		if(outside && pos != posPrev) {
			this.insertCurveAdjacent(geom, num - 1, num, posPrev!, pos, sign, isSurface, touchedTileList);
		}

		// Return the index of the first remaining point not inside this tile
		// (one past the last inserted point).
		return(num);
	}

	getGeometry() {
		return({
			then: (fn: (geometry: TileGeometry) => any) => fn(this)
		} as Promise<TileGeometry>);
	}

	findNearest(state: NearestState) {
		let px: number, py: number;
		let dist: number;
		let { x, y } = state;

		// Bail out if entire tile is further away than closest point found so far.
		if(this.sqDistTo(x, y) > state.dist) return(false);

		let { n, w, s, e } = state;

		const result = this.getGeometry().then((geom: TileGeometry) => {
			for(let pt of geom.pointList || []) {
				px = pt.x;
				py = pt.y;

				if(px >= s && py >= w && px <= n && py <= e) {
					px -= x;
					py -= y;

					dist = px * px + py * py;
					if(dist < state.dist) {
						state.result = pt;
						state.dist = dist;
					}
				}
			}
		});

		if(!result || typeof(result) != 'object' || typeof(result.then) != 'function') {
			return(state.result);
		}

		return(result.then(() => state.result));
	}

	split() {
		const childList = super.split();

		for(let geom of this.pointList) {
			this.insertPoint(geom);
		}

		for(let ref of this.curveList) {
			// this.insertCurve(...);
		}

		if(this.pointCount) {
			this.pointCount = 0;
			this.pointList = [];
			this.curveList = [];
		}

		return(childList);
	}

	/** Commit changes to a subtree.
	  * Useful when data is not only stored in memory.
	  * Subclassed methods could use exportPak to serialize the contents. */

	commit() {
		for(let child of this.childList || []) {
			child!.commit();
		}
	}

	summarize() {
		if(!this.childList) return;

		const { s, w, n, e } = this;
		const scaleX = 64 / (n - s);
		const scaleY = 64 / (e - w);
		const indexGrid: number[] = new Array(64 * 64);
		let index: number;
		let pos: number;
		let x: number;
		let y: number;

		this.pointWeightList = [];

		for(let child of this.childList) {
			if(!child) continue;

			child.summarize();

			let childWeightList = child.pointWeightList || [];
			let childPointNum = 0;

			for(let geom of child.pointList) {
				x = ~~((geom.x - s) * scaleX);
				y = ~~((geom.y - w) * scaleY);
				pos = y * 64 + x;

				index = indexGrid[pos];

				if(!index) {
					index = this.pointList.length + 1;
					this.pointList[index - 1] = geom;
					this.pointWeightList[index - 1] = 0;
					indexGrid[pos] = index;
					++this.pointCount;
				}

				this.pointWeightList[index - 1] += childWeightList[childPointNum++] || geom.weight || 1;
			}
		}
	}

	sqDistTo: (x: number, y: number) => number;
	getRegion: (x: number, y: number) => number;
	intersectsLine: (x1: number,y1: number,x2: number,y2: number) => boolean;

	/** Total number of points, including those defining curves and polygon edges. */
	pointCount = 0;
	pointList: cgeo.Point[] = [];
	/** Weight of each point, useful for clustering. */
	pointWeightList?: number[];

	curveList: StringRef[][] = [];

	tree: GeoTree;

}

GeoTile.prototype.sqDistTo = BBox.sqDistTo;
GeoTile.prototype.getRegion = BBox.getRegion;
GeoTile.prototype.intersectsLine = BBox.intersectsLine;
