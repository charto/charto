// This file is part of cgeo, copyright (c) 2017-2018 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { PointSpec, PointListSpec } from './Point';
import { Curve, CurveSpec } from './Curve';

export class String extends Curve implements PointListSpec {

	constructor(spec: PointSpec[] | PointListSpec = []) {
		super();

		this.init(spec);
	}

	init(spec: PointSpec[] | PointListSpec) {
		if(spec instanceof Array) {
			const count = spec.length;
			let pt: PointSpec;

			this.x = [];
			this.y = [];

			for(let num = 0; num < count; ++num) {
				pt = spec[num];
				this.x[num] = pt.x || 0;
				this.y[num] = pt.y || 0;
				if(pt.z !== void 0) (this.z || (this.z = []))[num] = pt.z;
				if(pt.m !== void 0) (this.m || (this.m = []))[num] = pt.m;
			}
		} else {
			this.x = spec.x || [];
			this.y = spec.y || [];
			if(spec.z !== void 0) this.z = spec.z;
			if(spec.m !== void 0) this.m = spec.m;
		}
	}

	clone() {
		return(new (this.constructor as any)({
			x: this.x && this.x.slice(0),
			y: this.y && this.y.slice(0),
			z: this.z && this.z.slice(0),
			m: this.m && this.m.slice(0)
		}));
	}

	transform(handler: (pt: PointSpec) => void, pt: PointSpec = {}) {
		const { x, y, z, m } = this;
		const count = x.length;

		pt.z = void 0;
		pt.m = void 0;

		for(let num = 0; num < count; ++num) {
			pt.x = x[num];
			pt.y = y[num];
			if(z) pt.z = z[num];
			if(m) pt.m = m[num];

			handler(pt);

			x[num] = pt.x;
			y[num] = pt.y;
			if(z) z[num] = pt.z!;
			if(m) m[num] = pt.m!;
		}

		return(this);
	}

	hasZ() { return(this.z !== void 0); }
	hasM() { return(this.m !== void 0); }

	x: number[];
	y: number[];
	z?: number[];
	m?: number[];
	ids?: (number | string | null | undefined)[];

}
