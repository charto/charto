// This file is part of charto-model, copyright (c) 2017 BusFaster Ltd.
// Released under the MIT license, see LICENSE.

import { detSign } from 'cmath';
import { SRS } from './SRS';

export interface BBoxLike {
	s: number;
	w: number;
	n: number;
	e: number;
}

export class BBox implements BBoxLike {

	constructor(
		public readonly s: number,
		public readonly w: number,
		public readonly n: number,
		public readonly e: number,
		public readonly srs?: number
	) {}

	static fromArray(spec: (number | string)[], srs: SRS) {
		if(srs.oldXY) {
			// Helsinki: 24,60,24,60,epsg:4326
			return(new BBox(+spec[1], +spec[0], +spec[3], +spec[2], srs.epsg));
		} else {
			// Helsinki: 60,24,60,24,urn:ogc:def:crs:epsg::4326
			return(new BBox(+spec[0], +spec[1], +spec[2], +spec[3], srs.epsg));
		}
	}

	toArray(oldXY?: boolean) {
		return(oldXY ?
			[this.w, this.s, this.e, this.n, this.srs] :
			[this.s, this.w, this.n, this.e, this.srs]
		);
	}

	clone() {
		return(new BBox(this.s, this.w, this.n, this.e, this.srs));
	}

	static sqDistTo(this: any, x: number, y: number, bbox: BBoxLike = this) {
		let dx = 0, dy = 0;

		if(x < bbox.s) dx = x - bbox.s;
		else if(x > bbox.n) dx = x - bbox.n;

		if(y < this.w) dy = y - bbox.w;
		else if(y >= this.e) dy = y - bbox.e;

		return(dx * dx + dy * dy);
	}

	/*
		The Sutherland-Cohen clipping algorithm extends to infinity the edges of a
		rectangular viewport used to filter out invisible geometry. The extended
		edges partition the coordinate system into 9 regions like this:

		v               v
		1100 | 0100 | 0110
		-----+------+-----
		1000 | 0000 | 0010
		-----+------+-----
		1001 | 0001 | 0011

		Result is a 4-bit code where each bit represents being on the outside of a
		particular edge.
	*/

	static getRegion(this: any, x: number, y: number, bbox: BBoxLike = this) {
		return(
			(x < bbox.s ? 8 : 0) |
			(y < bbox.w ? 4 : 0) |
			(x >= bbox.n ? 2 : 0) |
			(y >= bbox.e ? 1 : 0)
		);
	}

	static intersectsLine(
		this: any,
		x1: number,
		y1: number,
		x2: number,
		y2: number,
		bbox: BBoxLike = this
	) {
		// The algorithm begins like Sutherland-Cohen by finding region codes of
		// line endpoints.

		const region1 = BBox.getRegion(x1, y1, bbox);
		const region2 = BBox.getRegion(x2, y2, bbox);

		// Check if a line end point is inside the box (region 0000).
		if(!region1 || !region2) return(true);

		// Check if the regions of line endpoints have a bit set in
		// the same position meaning the line is completely outside one of the
		// extended edges of the box (see figure in getRegion comments).
		if(region1 & region2) return(false);

		// Check the if line goes between opposite regions (after combining set bits,
		// there will be two equal bit pairs: 0101 or 1010 or 1111).
		const mask = region1 | region2;

		if(!((mask ^ mask >> 2) & 3)) {

			// If line goes diagonally between opposite regions, their bits
			// combined will be 1111 and it's hard to tell which sides it crosses.

			if(mask == 15) {

				// Two cross products are needed.
				let cx1: number, cy1: number;
				let cx2: number, cy2: number;

				if(y1 < y2 != x1 < x2) {
					cx1 = bbox.s;
					cy1 = bbox.w;
					cx2 = bbox.n;
					cy2 = bbox.e;
				} else {
					cx1 = bbox.n;
					cy1 = bbox.w;
					cx2 = bbox.s;
					cy2 = bbox.e;
				}

				const sign = x1 > x2 ? -1 : 1;

				return(
					detSign(x2 - x1, y2 - y1, cx1 - x1, cy1 - y1) * sign < 0 &&
					detSign(x2 - x1, y2 - y1, cx2 - x2, cy2 - y2) * sign > 0
				);

			} else {

				// Line goes between directly above and below or left and right
				// sides of the box so it must intersect.
				return(true);
			}
		}

		/*
			The line begins or ends in a region that shares an edge with the box.
			Intersection is determined by whether one of the box corners is on the
			left or right side of the line.

			Determine which corner and which side means what.
			Convert region bit codes of line endpoints into sequential numbers:

			2 | 1 | 0
			3 |   | 7
			4 | 5 | 6

			This is based on something in the spirit of a De Bruijn sequence.
			Partially overlapping 3-bit codes are packed into a 32-bit value
			like this:

			         _11_                   _2_  _0_
			         | ||                   |||  |||
			_15      | |_10    __7_ __5_    ||__1_||  <- From
			|||      | ||||    | || | ||    ||| ||||
			 1000 0000 1100 0000 0100 0000 0101 1110  <- Mask (80c0405e)
			|||       \||||     \||  \||    |||\||||
			010       ::100     001  000    101::110  <- To (binary)
			 |        011:       |    |      | 111:
			 |         | |       |    |      |  | |
			 2         3 4       1    0      5  7 6         (decimal)
		*/

		const octant1 = 0x80c0405e >>> ((region1 ^ 3) << 1);
		const octant2 = 0x80c0405e >>> ((region2 ^ 3) << 1);

		// Corner that intersects first and which side of the line it may be on
		// means an intersection depend on whether it's faster to go clockwise
		// (flag set) or counterclockwise (flag not set) around the box from
		// line start to end.

		const flag = octant2 - octant1 & 4;

		// Figure out the corner coordinates.

		const corner = (octant1 >> 1) - (flag >> ((octant1 & 1) + 1));

		const cx = corner & 2 ? bbox.n : bbox.s;
		const cy = (corner ^ (corner >> 1)) & 1 ? bbox.e : bbox.w;

		// Check which side of the line the corner is on and return intersection
		// test result.

		return(flag ?
			detSign(x2 - x1, y2 - y1, cx - x1, cy - y1) < 0 :
			detSign(x1 - x2, y1 - y2, cx - x2, cy - y2) < 0
		);
	}

	sqDistTo: (x: number, y: number) => number;
	getRegion: (x: number, y: number) => number;
	intersectsLine: (x1: number, y1: number, x2: number, y2: number) => boolean;

	area() {
		return((this.n - this.s) * (this.e - this.w));
	}

	extended(lat: number, lon: number) {
		const { s, w, n, e } = this;

		return(new BBox(
			lat < s ? lat : s,
			lon < w ? lon : w,
			lat > n ? lat : n,
			lon > e ? lon : e,
			this.srs
		));
	}

}

BBox.prototype.sqDistTo = BBox.sqDistTo;
BBox.prototype.getRegion = BBox.getRegion;
BBox.prototype.intersectsLine = BBox.intersectsLine;
